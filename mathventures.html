<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mathventures: The Crystal Kingdom - Phaser Edition</title>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.70.0/dist/phaser.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Cinzel:wght@600&family=MedievalSharp&display=swap');
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: linear-gradient(135deg, #1a1a2e, #16213e);
            font-family: 'MedievalSharp', cursive;
        }

        #game-container {
            border: 5px solid transparent;
            border-image: linear-gradient(45deg, #8B7355, #D4AF37, #8B7355) 1;
            box-shadow: 0 0 30px rgba(212, 175, 55, 0.5);
        }

        .math-modal {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, #2d1b69, #0a0e27);
            border: 4px solid #D4AF37;
            border-radius: 20px;
            padding: 30px;
            display: none;
            z-index: 1000;
            box-shadow: 0 0 50px rgba(255,215,0,0.6);
            color: white;
            min-width: 400px;
        }

        .math-modal.active {
            display: block;
        }

        .math-title {
            font-family: 'Cinzel', serif;
            color: #FFD700;
            font-size: 2em;
            text-align: center;
            margin-bottom: 20px;
        }

        .math-question {
            background: rgba(255,255,255,0.9);
            color: #2d1b69;
            font-size: 1.8em;
            text-align: center;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
            font-weight: bold;
        }

        .math-answers {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 15px;
        }

        .answer-btn {
            background: linear-gradient(135deg, #8B4513, #D2691E);
            color: #FFD700;
            border: 2px solid #D4AF37;
            padding: 15px;
            border-radius: 10px;
            font-size: 1.3em;
            cursor: pointer;
            transition: all 0.3s;
            font-family: 'MedievalSharp', cursive;
        }

        .answer-btn:hover {
            background: linear-gradient(135deg, #A0522D, #DEB887);
            transform: scale(1.05);
        }

        .answer-btn.correct {
            background: linear-gradient(135deg, #228B22, #32CD32);
            animation: pulse 0.5s;
        }

        .answer-btn.wrong {
            background: linear-gradient(135deg, #8B0000, #DC143C);
            animation: shake 0.5s;
        }

        @keyframes pulse {
            50% { transform: scale(1.1); }
        }

        @keyframes shake {
            25% { transform: translateX(-10px); }
            75% { transform: translateX(10px); }
        }
    </style>
</head>
<body>
    <div id="game-container"></div>
    
    <div class="math-modal" id="mathModal">
        <h2 class="math-title">Math Battle!</h2>
        <div class="math-question" id="mathQuestion">Loading...</div>
        <div class="math-answers" id="mathAnswers"></div>
    </div>

    <script>
        // Game configuration
        const config = {
            type: Phaser.AUTO,
            width: 1200,
            height: 600,
            parent: 'game-container',
            physics: {
                default: 'arcade',
                arcade: {
                    gravity: { y: 800 },
                    debug: false
                }
            },
            scene: [TitleScene, GameScene, LevelCompleteScene, VictoryScene]
        };

        // Title Scene
        class TitleScene extends Phaser.Scene {
            constructor() {
                super({ key: 'TitleScene' });
            }

            create() {
                // Gradient background
                const graphics = this.add.graphics();
                const gradient = graphics.createLinearGradient(0, 0, 0, 600);
                gradient.addColorStop(0, 0x0a0e27);
                gradient.addColorStop(0.5, 0x1a1f3a);
                gradient.addColorStop(1, 0x2d1b69);
                graphics.fillGradientStyle(gradient);
                graphics.fillRect(0, 0, 1200, 600);

                // Animated stars
                for (let i = 0; i < 100; i++) {
                    const star = this.add.circle(
                        Phaser.Math.Between(0, 1200),
                        Phaser.Math.Between(0, 600),
                        Phaser.Math.Between(1, 3),
                        0xFFFFFF
                    );
                    star.setAlpha(Phaser.Math.FloatBetween(0.3, 1));
                    this.tweens.add({
                        targets: star,
                        alpha: { from: star.alpha, to: 0 },
                        duration: Phaser.Math.Between(2000, 4000),
                        repeat: -1,
                        yoyo: true
                    });
                }

                // Title
                const title = this.add.text(600, 150, 'MATHVENTURES', {
                    fontFamily: 'Cinzel',
                    fontSize: '80px',
                    color: '#FFD700',
                    stroke: '#8B4513',
                    strokeThickness: 6
                });
                title.setOrigin(0.5);
                title.setShadow(5, 5, 'rgba(0,0,0,0.5)', 10);

                // Floating animation for title
                this.tweens.add({
                    targets: title,
                    y: '+=20',
                    duration: 2000,
                    ease: 'Sine.inOut',
                    repeat: -1,
                    yoyo: true
                });

                // Subtitle
                const subtitle = this.add.text(600, 230, 'The Crystal Kingdom', {
                    fontFamily: 'MedievalSharp',
                    fontSize: '36px',
                    color: '#FFA500'
                });
                subtitle.setOrigin(0.5);

                // Story text
                const storyBg = this.add.rectangle(600, 350, 700, 120, 0x000000, 0.7);
                const story = this.add.text(600, 350, 
                    'The evil sorcerer Malathor has captured Princess Arithmia!\n' +
                    'Only a true Math Wizard can defeat his minions and save the realm.\n' +
                    'Journey through 5 magical worlds to rescue her!',
                    {
                        fontFamily: 'MedievalSharp',
                        fontSize: '20px',
                        color: '#F0E68C',
                        align: 'center',
                        lineSpacing: 5
                    }
                );
                story.setOrigin(0.5);

                // Play button
                const playBtn = this.add.rectangle(600, 480, 250, 70, 0x8B4513);
                playBtn.setStrokeStyle(3, 0xD4AF37);
                playBtn.setInteractive({ useHandCursor: true });
                
                const playText = this.add.text(600, 480, 'Begin Quest', {
                    fontFamily: 'MedievalSharp',
                    fontSize: '32px',
                    color: '#FFD700'
                });
                playText.setOrigin(0.5);

                // Button hover effects
                playBtn.on('pointerover', () => {
                    playBtn.setScale(1.1);
                    this.tweens.add({
                        targets: playBtn,
                        alpha: 0.8,
                        duration: 200
                    });
                });

                playBtn.on('pointerout', () => {
                    playBtn.setScale(1);
                    playBtn.setAlpha(1);
                });

                playBtn.on('pointerdown', () => {
                    this.scene.start('GameScene', { level: 1, score: 0, health: 5 });
                });

                // Add decorative wizard sprite
                this.createWizardPreview();
            }

            createWizardPreview() {
                const wizard = this.add.container(600, 350);
                
                // Body
                const body = this.add.ellipse(0, 20, 40, 60, 0x4169E1);
                
                // Head
                const head = this.add.circle(0, -10, 15, 0xFDBCB4);
                
                // Hat
                const hat = this.add.triangle(0, -25, -20, 0, 0, -30, 20, 0, 0x4B0082);
                
                // Staff
                const staff = this.add.rectangle(25, 10, 5, 50, 0x8B4513);
                const orb = this.add.circle(25, -20, 8, 0xFFD700);
                
                wizard.add([body, head, hat, staff, orb]);
                wizard.setScale(2);
                
                // Floating animation
                this.tweens.add({
                    targets: wizard,
                    y: '+=15',
                    duration: 2000,
                    ease: 'Sine.inOut',
                    repeat: -1,
                    yoyo: true
                });
                
                // Glow effect on orb
                this.tweens.add({
                    targets: orb,
                    scaleX: 1.5,
                    scaleY: 1.5,
                    alpha: 0.7,
                    duration: 1000,
                    ease: 'Sine.inOut',
                    repeat: -1,
                    yoyo: true
                });
            }
        }

        // Main Game Scene
        class GameScene extends Phaser.Scene {
            constructor() {
                super({ key: 'GameScene' });
                this.currentLevel = 1;
                this.score = 0;
                this.health = 5;
                this.mana = 3;
                this.enemiesDefeated = 0;
                this.treasuresCollected = 0;
                this.canEnterPortal = false;
            }

            init(data) {
                this.currentLevel = data.level || 1;
                this.score = data.score || 0;
                this.health = data.health || 5;
            }

            create() {
                // Level backgrounds
                this.createBackground();
                
                // Create platforms
                this.platforms = this.physics.add.staticGroup();
                this.createPlatforms();
                
                // Create player
                this.createPlayer();
                
                // Create enemies
                this.enemies = this.physics.add.group();
                this.createEnemies();
                
                // Create treasures
                this.treasures = this.physics.add.group();
                this.createTreasures();
                
                // Create portal
                this.createPortal();
                
                // Create projectiles group
                this.projectiles = this.physics.add.group();
                
                // Set up collisions
                this.physics.add.collider(this.player, this.platforms);
                this.physics.add.collider(this.enemies, this.platforms);
                this.physics.add.collider(this.treasures, this.platforms);
                
                // Overlaps
                this.physics.add.overlap(this.player, this.treasures, this.collectTreasure, null, this);
                this.physics.add.overlap(this.player, this.portal, this.enterPortal, null, this);
                this.physics.add.overlap(this.projectiles, this.enemies, this.hitEnemy, null, this);
                this.physics.add.overlap(this.projectiles, this.platforms, this.destroyProjectile, null, this);
                
                // Controls
                this.cursors = this.input.keyboard.createCursorKeys();
                this.spaceKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);
                
                // HUD
                this.createHUD();
                
                // Camera
                this.cameras.main.setBounds(0, 0, 2400, 600);
                this.cameras.main.startFollow(this.player, true, 0.05, 0.05);
                
                // Enemy click handling
                this.input.on('pointerdown', this.handleClick, this);
                
                // Show level intro
                this.showLevelIntro();
            }

            createBackground() {
                const colors = [
                    { sky1: 0x87CEEB, sky2: 0x98FB98 }, // Forest
                    { sky1: 0x483D8B, sky2: 0x6A5ACD }, // Cave
                    { sky1: 0x8B0000, sky2: 0xFF4500 }, // Lava
                    { sky1: 0xB0E0E6, sky2: 0xE0FFFF }, // Ice
                    { sky1: 0x1C1C1C, sky2: 0x4B0082 }  // Castle
                ];
                
                const levelColors = colors[Math.min(this.currentLevel - 1, 4)];
                
                // Gradient background
                const graphics = this.add.graphics();
                const gradient = graphics.createLinearGradient(0, 0, 0, 600);
                gradient.addColorStop(0, levelColors.sky1);
                gradient.addColorStop(1, levelColors.sky2);
                graphics.fillGradientStyle(gradient);
                graphics.fillRect(0, 0, 2400, 600);
                
                // Parallax elements
                for (let i = 0; i < 10; i++) {
                    const x = i * 300;
                    const element = this.add.ellipse(x, 200, 100, 80, levelColors.sky1, 0.3);
                    element.setScrollFactor(0.5); // Parallax effect
                }
            }

            createPlatforms() {
                // Ground platforms
                for (let i = 0; i < 12; i++) {
                    const ground = this.add.rectangle(i * 200 + 100, 550, 200, 100, 0x228B22);
                    this.platforms.add(ground);
                }
                
                // Floating platforms
                const platformPositions = [
                    { x: 400, y: 400 },
                    { x: 700, y: 350 },
                    { x: 1000, y: 300 },
                    { x: 1300, y: 350 },
                    { x: 1600, y: 280 },
                    { x: 1900, y: 350 }
                ];
                
                platformPositions.forEach(pos => {
                    const platform = this.add.rectangle(pos.x, pos.y, 150, 20, 0x8B4513);
                    platform.setStrokeStyle(2, 0xD4AF37);
                    this.platforms.add(platform);
                    
                    // Add floating animation
                    this.tweens.add({
                        targets: platform,
                        y: pos.y - 10,
                        duration: 2000,
                        ease: 'Sine.inOut',
                        repeat: -1,
                        yoyo: true
                    });
                });
            }

            createPlayer() {
                this.player = this.physics.add.container(100, 400);
                
                // Player body parts
                const body = this.add.ellipse(0, 0, 30, 40, 0x4169E1);
                const head = this.add.circle(0, -25, 12, 0xFDBCB4);
                const hat = this.add.triangle(0, -35, -15, -20, 0, -45, 15, -20, 0x4B0082);
                const staff = this.add.rectangle(15, 0, 4, 40, 0x8B4513);
                const orb = this.add.circle(15, -22, 6, 0xFFD700);
                
                this.player.add([body, head, hat, staff, orb]);
                this.player.setSize(30, 60);
                this.physics.world.enable(this.player);
                this.player.body.setCollideWorldBounds(true);
                
                // Store orb reference for animations
                this.player.orb = orb;
                
                // Walking animation
                this.player.walkAnim = this.tweens.add({
                    targets: this.player,
                    scaleX: 1.05,
                    duration: 200,
                    yoyo: true,
                    repeat: -1,
                    paused: true
                });
            }

            createEnemies() {
                const enemyTypes = [
                    { name: 'slime', color: 0x90EE90, health: 2, points: 50 },
                    { name: 'goblin', color: 0x8B4513, health: 3, points: 100 },
                    { name: 'demon', color: 0x8B008B, health: 4, points: 150 }
                ];
                
                const enemyCount = 3 + this.currentLevel * 2;
                
                for (let i = 0; i < enemyCount; i++) {
                    const type = enemyTypes[Math.min(Math.floor(i / 2), 2)];
                    const x = 400 + i * 200;
                    const y = 400;
                    
                    const enemy = this.physics.add.container(x, y);
                    
                    // Enemy body
                    const enemyBody = this.add.ellipse(0, 0, 40, 40, type.color);
                    const eyes = [
                        this.add.circle(-8, -5, 4, 0xFFFFFF),
                        this.add.circle(8, -5, 4, 0xFFFFFF),
                        this.add.circle(-8, -5, 2, 0x000000),
                        this.add.circle(8, -5, 2, 0x000000)
                    ];
                    
                    enemy.add([enemyBody, ...eyes]);
                    enemy.setSize(40, 40);
                    enemy.setInteractive();
                    
                    // Enemy properties
                    enemy.enemyData = {
                        name: type.name,
                        health: type.health,
                        maxHealth: type.health,
                        points: type.points,
                        defeated: false
                    };
                    
                    // Health bar
                    const healthBarBg = this.add.rectangle(0, -30, 40, 6, 0x000000);
                    const healthBar = this.add.rectangle(0, -30, 40, 6, 0xFF0000);
                    enemy.add([healthBarBg, healthBar]);
                    enemy.healthBar = healthBar;
                    
                    this.enemies.add(enemy);
                    
                    // Enemy movement
                    enemy.body.setVelocityX(Phaser.Math.Between(-50, 50));
                    enemy.body.setBounce(1, 0);
                    enemy.body.setCollideWorldBounds(true);
                    
                    // Floating animation
                    this.tweens.add({
                        targets: enemy,
                        y: y - 10,
                        duration: 1500,
                        ease: 'Sine.inOut',
                        repeat: -1,
                        yoyo: true
                    });
                }
            }

            createTreasures() {
                for (let i = 0; i < 5; i++) {
                    const x = 300 + i * 350;
                    const y = 300;
                    
                    const treasure = this.physics.add.sprite(x, y);
                    const gem = this.add.polygon(0, 0, '0,-15 -10,-5 -10,5 0,15 10,5 10,-5', 0xFF1493);
                    treasure.add(gem);
                    
                    treasure.treasureData = { value: 50, collected: false };
                    
                    this.treasures.add(treasure);
                    
                    // Rotation animation
                    this.tweens.add({
                        targets: gem,
                        rotation: Math.PI * 2,
                        duration: 3000,
                        repeat: -1
                    });
                    
                    // Floating
                    this.tweens.add({
                        targets: treasure,
                        y: y - 15,
                        duration: 2000,
                        ease: 'Sine.inOut',
                        repeat: -1,
                        yoyo: true
                    });
                }
            }

            createPortal() {
                this.portal = this.add.container(2200, 400);
                
                // Portal rings
                const rings = [];
                for (let i = 0; i < 3; i++) {
                    const ring = this.add.ellipse(0, 0, 80 + i * 20, 100 + i * 20);
                    ring.setStrokeStyle(4, 0xFFD700);
                    ring.setAlpha(1 - i * 0.2);
                    rings.push(ring);
                    
                    // Rotate rings
                    this.tweens.add({
                        targets: ring,
                        rotation: Math.PI * 2 * (i % 2 === 0 ? 1 : -1),
                        duration: 3000 + i * 500,
                        repeat: -1
                    });
                }
                
                // Portal particles
                for (let i = 0; i < 8; i++) {
                    const angle = (i / 8) * Math.PI * 2;
                    const particle = this.add.circle(
                        Math.cos(angle) * 40,
                        Math.sin(angle) * 50,
                        5,
                        0xFFD700
                    );
                    
                    this.tweens.add({
                        targets: particle,
                        x: Math.cos(angle) * 20,
                        y: Math.sin(angle) * 25,
                        alpha: { from: 1, to: 0.3 },
                        duration: 1500,
                        repeat: -1,
                        yoyo: true
                    });
                    
                    this.portal.add(particle);
                }
                
                this.portal.add(rings);
                this.physics.world.enable(this.portal);
                this.portal.body.setSize(80, 100);
                
                // Portal lock/unlock indicator
                this.portalLock = this.add.text(0, -80, '🔒', {
                    fontSize: '32px'
                });
                this.portal.add(this.portalLock);
            }

            createHUD() {
                const hudBg = this.add.rectangle(600, 30, 1150, 60, 0x000000, 0.7);
                hudBg.setScrollFactor(0);
                
                // Level indicator
                this.levelText = this.add.text(50, 30, `Level ${this.currentLevel}`, {
                    fontFamily: 'MedievalSharp',
                    fontSize: '24px',
                    color: '#FFD700'
                });
                this.levelText.setScrollFactor(0);
                
                // Health
                this.healthDisplay = [];
                for (let i = 0; i < 5; i++) {
                    const heart = this.add.text(300 + i * 30, 30, '❤️', {
                        fontSize: '24px'
                    });
                    heart.setScrollFactor(0);
                    this.healthDisplay.push(heart);
                }
                
                // Score
                this.scoreText = this.add.text(600, 30, `Score: ${this.score}`, {
                    fontFamily: 'MedievalSharp',
                    fontSize: '24px',
                    color: '#FFD700'
                });
                this.scoreText.setOrigin(0.5);
                this.scoreText.setScrollFactor(0);
                
                // Progress
                this.progressText = this.add.text(900, 30, `Enemies: ${this.enemiesDefeated}/${3 + this.currentLevel}`, {
                    fontFamily: 'MedievalSharp',
                    fontSize: '20px',
                    color: '#F0E68C'
                });
                this.progressText.setScrollFactor(0);
            }

            showLevelIntro() {
                const levelNames = [
                    'Enchanted Forest',
                    'Crystal Caves',
                    'Lava Mountain',
                    'Frozen Wastes',
                    'Dark Castle'
                ];
                
                const introText = this.add.text(600, 300, levelNames[this.currentLevel - 1], {
                    fontFamily: 'Cinzel',
                    fontSize: '48px',
                    color: '#FFD700',
                    stroke: '#8B4513',
                    strokeThickness: 4
                });
                introText.setOrigin(0.5);
                introText.setScrollFactor(0);
                introText.setAlpha(0);
                
                this.tweens.add({
                    targets: introText,
                    alpha: 1,
                    scale: { from: 0.5, to: 1 },
                    duration: 1000,
                    ease: 'Back.out',
                    onComplete: () => {
                        this.time.delayedCall(1500, () => {
                            this.tweens.add({
                                targets: introText,
                                alpha: 0,
                                scale: 1.5,
                                duration: 800,
                                onComplete: () => introText.destroy()
                            });
                        });
                    }
                });
            }

            update() {
                // Player movement
                if (this.cursors.left.isDown) {
                    this.player.body.setVelocityX(-200);
                    this.player.setScale(-1, 1);
                    this.player.walkAnim.resume();
                } else if (this.cursors.right.isDown) {
                    this.player.body.setVelocityX(200);
                    this.player.setScale(1, 1);
                    this.player.walkAnim.resume();
                } else {
                    this.player.body.setVelocityX(0);
                    this.player.walkAnim.pause();
                }
                
                // Jump
                if (this.cursors.up.isDown && this.player.body.touching.down) {
                    this.player.body.setVelocityY(-500);
                    this.createJumpParticles();
                }
                
                // Cast spell
                if (Phaser.Input.Keyboard.JustDown(this.spaceKey)) {
                    this.castSpell();
                }
                
                // Update portal lock
                const requiredEnemies = 3 + this.currentLevel;
                if (this.enemiesDefeated >= requiredEnemies && !this.canEnterPortal) {
                    this.canEnterPortal = true;
                    this.portalLock.setText('✅');
                    this.tweens.add({
                        targets: this.portal,
                        scaleX: 1.2,
                        scaleY: 1.2,
                        duration: 500,
                        yoyo: true
                    });
                }
            }

            castSpell() {
                const projectile = this.physics.add.sprite(
                    this.player.x + (this.player.scaleX > 0 ? 20 : -20),
                    this.player.y
                );
                
                const spell = this.add.circle(0, 0, 8, 0x00BFFF);
                projectile.add(spell);
                
                projectile.body.setVelocityX(this.player.scaleX > 0 ? 400 : -400);
                projectile.body.setGravityY(-800);
                
                this.projectiles.add(projectile);
                
                // Spell animation
                this.tweens.add({
                    targets: spell,
                    scaleX: 1.5,
                    scaleY: 1.5,
                    alpha: 0.5,
                    duration: 200,
                    yoyo: true,
                    repeat: -1
                });
                
                // Destroy after 2 seconds
                this.time.delayedCall(2000, () => {
                    projectile.destroy();
                });
            }

            hitEnemy(projectile, enemy) {
                if (enemy.enemyData.defeated) return;
                
                projectile.destroy();
                
                // Damage enemy
                enemy.enemyData.health--;
                
                // Update health bar
                const healthPercent = enemy.enemyData.health / enemy.enemyData.maxHealth;
                enemy.healthBar.scaleX = healthPercent;
                
                // Hit effect
                this.tweens.add({
                    targets: enemy,
                    tint: 0xFF0000,
                    duration: 100,
                    yoyo: true,
                    onComplete: () => enemy.clearTint()
                });
                
                if (enemy.enemyData.health <= 0) {
                    this.defeatEnemy(enemy);
                }
            }

            handleClick(pointer) {
                const worldPoint = this.cameras.main.getWorldPoint(pointer.x, pointer.y);
                
                this.enemies.children.entries.forEach(enemy => {
                    if (!enemy.enemyData.defeated && 
                        Phaser.Geom.Rectangle.Contains(enemy.getBounds(), worldPoint.x, worldPoint.y)) {
                        const distance = Phaser.Math.Distance.Between(
                            this.player.x, this.player.y,
                            enemy.x, enemy.y
                        );
                        
                        if (distance < 200) {
                            this.startMathBattle(enemy);
                        }
                    }
                });
            }

            startMathBattle(enemy) {
                this.scene.pause();
                this.currentEnemy = enemy;
                
                const modal = document.getElementById('mathModal');
                modal.classList.add('active');
                
                this.generateMathQuestion();
            }

            generateMathQuestion() {
                const operations = ['add', 'subtract', 'multiply', 'divide'];
                const operation = operations[Math.floor(Math.random() * 4)];
                
                let question, answer;
                const difficulty = this.currentLevel;
                
                switch(operation) {
                    case 'add':
                        const a1 = Math.floor(Math.random() * (30 * difficulty)) + 10;
                        const a2 = Math.floor(Math.random() * (30 * difficulty)) + 10;
                        question = `${a1} + ${a2}`;
                        answer = a1 + a2;
                        break;
                    case 'subtract':
                        const s1 = Math.floor(Math.random() * (50 * difficulty)) + 50;
                        const s2 = Math.floor(Math.random() * (30 * difficulty)) + 10;
                        question = `${s1} - ${s2}`;
                        answer = s1 - s2;
                        break;
                    case 'multiply':
                        const m1 = Math.floor(Math.random() * (8 + difficulty)) + 2;
                        const m2 = Math.floor(Math.random() * 12) + 2;
                        question = `${m1} × ${m2}`;
                        answer = m1 * m2;
                        break;
                    case 'divide':
                        const divisor = Math.floor(Math.random() * 10) + 2;
                        const quotient = Math.floor(Math.random() * (10 + difficulty)) + 2;
                        question = `${divisor * quotient} ÷ ${divisor}`;
                        answer = quotient;
                        break;
                }
                
                document.getElementById('mathQuestion').textContent = question + ' = ?';
                
                // Generate options
                const options = [answer];
                while (options.length < 4) {
                    const wrong = answer + Math.floor(Math.random() * 20) - 10;
                    if (!options.includes(wrong) && wrong > 0) {
                        options.push(wrong);
                    }
                }
                options.sort(() => Math.random() - 0.5);
                
                // Create answer buttons
                const answersDiv = document.getElementById('mathAnswers');
                answersDiv.innerHTML = '';
                
                options.forEach(option => {
                    const btn = document.createElement('button');
                    btn.className = 'answer-btn';
                    btn.textContent = option;
                    btn.onclick = () => this.checkAnswer(option, answer, btn);
                    answersDiv.appendChild(btn);
                });
            }

            checkAnswer(selected, correct, button) {
                const buttons = document.querySelectorAll('.answer-btn');
                buttons.forEach(btn => btn.disabled = true);
                
                if (selected === correct) {
                    button.classList.add('correct');
                    this.score += 100 * this.currentLevel;
                    this.scoreText.setText(`Score: ${this.score}`);
                    
                    setTimeout(() => {
                        document.getElementById('mathModal').classList.remove('active');
                        this.scene.resume();
                        this.defeatEnemy(this.currentEnemy);
                    }, 1000);
                } else {
                    button.classList.add('wrong');
                    buttons.forEach(btn => {
                        if (parseInt(btn.textContent) === correct) {
                            btn.classList.add('correct');
                        }
                    });
                    
                    this.health--;
                    this.updateHealthDisplay();
                    
                    setTimeout(() => {
                        if (this.health <= 0) {
                            alert('Game Over!');
                            location.reload();
                        } else {
                            this.generateMathQuestion();
                        }
                    }, 1500);
                }
            }

            defeatEnemy(enemy) {
                enemy.enemyData.defeated = true;
                this.enemiesDefeated++;
                this.progressText.setText(`Enemies: ${this.enemiesDefeated}/${3 + this.currentLevel}`);
                
                // Defeat animation
                this.tweens.add({
                    targets: enemy,
                    alpha: 0,
                    scaleX: 0,
                    scaleY: 0,
                    rotation: Math.PI * 2,
                    duration: 500,
                    onComplete: () => enemy.destroy()
                });
                
                // Particles
                for (let i = 0; i < 10; i++) {
                    const particle = this.add.circle(enemy.x, enemy.y, 4, 0xFFD700);
                    this.tweens.add({
                        targets: particle,
                        x: enemy.x + Phaser.Math.Between(-50, 50),
                        y: enemy.y + Phaser.Math.Between(-50, 50),
                        alpha: 0,
                        duration: 800,
                        onComplete: () => particle.destroy()
                    });
                }
            }

            collectTreasure(player, treasure) {
                if (treasure.treasureData.collected) return;
                
                treasure.treasureData.collected = true;
                this.treasuresCollected++;
                this.score += treasure.treasureData.value;
                this.scoreText.setText(`Score: ${this.score}`);
                
                // Collection animation
                this.tweens.add({
                    targets: treasure,
                    y: treasure.y - 50,
                    alpha: 0,
                    scale: 2,
                    duration: 500,
                    onComplete: () => treasure.destroy()
                });
            }

            enterPortal(player, portal) {
                if (!this.canEnterPortal) return;
                
                this.canEnterPortal = false; // Prevent multiple triggers
                
                // Portal entry animation
                this.tweens.add({
                    targets: this.player,
                    x: portal.x,
                    y: portal.y,
                    scaleX: 0,
                    scaleY: 0,
                    rotation: Math.PI * 4,
                    duration: 1000,
                    onComplete: () => {
                        if (this.currentLevel >= 5) {
                            this.scene.start('VictoryScene', { score: this.score });
                        } else {
                            this.scene.start('LevelCompleteScene', { 
                                level: this.currentLevel,
                                score: this.score,
                                health: this.health
                            });
                        }
                    }
                });
            }

            createJumpParticles() {
                for (let i = 0; i < 5; i++) {
                    const particle = this.add.circle(
                        this.player.x + Phaser.Math.Between(-10, 10),
                        this.player.y + 30,
                        3,
                        0x87CEEB
                    );
                    
                    this.tweens.add({
                        targets: particle,
                        y: particle.y + 20,
                        alpha: 0,
                        duration: 500,
                        onComplete: () => particle.destroy()
                    });
                }
            }

            destroyProjectile(projectile) {
                projectile.destroy();
            }

            updateHealthDisplay() {
                for (let i = 0; i < 5; i++) {
                    if (i < this.health) {
                        this.healthDisplay[i].setText('❤️');
                    } else {
                        this.healthDisplay[i].setText('💔');
                    }
                }
            }
        }

        // Level Complete Scene
        class LevelCompleteScene extends Phaser.Scene {
            constructor() {
                super({ key: 'LevelCompleteScene' });
            }

            init(data) {
                this.currentLevel = data.level;
                this.score = data.score;
                this.health = data.health;
            }

            create() {
                // Background
                const graphics = this.add.graphics();
                graphics.fillStyle(0x2d1b69, 0.9);
                graphics.fillRect(0, 0, 1200, 600);
                
                // Title
                const title = this.add.text(600, 150, 'Level Complete!', {
                    fontFamily: 'Cinzel',
                    fontSize: '64px',
                    color: '#FFD700',
                    stroke: '#8B4513',
                    strokeThickness: 4
                });
                title.setOrigin(0.5);
                
                // Animation
                this.tweens.add({
                    targets: title,
                    scaleX: 1.1,
                    scaleY: 1.1,
                    duration: 1000,
                    ease: 'Sine.inOut',
                    repeat: -1,
                    yoyo: true
                });
                
                // Stats
                const stats = this.add.text(600, 300, 
                    `Score: ${this.score}\nHealth Remaining: ${this.health}`,
                    {
                        fontFamily: 'MedievalSharp',
                        fontSize: '32px',
                        color: '#F0E68C',
                        align: 'center',
                        lineSpacing: 10
                    }
                );
                stats.setOrigin(0.5);
                
                // Continue button
                const continueBtn = this.add.rectangle(600, 450, 250, 70, 0x8B4513);
                continueBtn.setStrokeStyle(3, 0xD4AF37);
                continueBtn.setInteractive({ useHandCursor: true });
                
                const btnText = this.add.text(600, 450, 'Next Level', {
                    fontFamily: 'MedievalSharp',
                    fontSize: '32px',
                    color: '#FFD700'
                });
                btnText.setOrigin(0.5);
                
                continueBtn.on('pointerover', () => {
                    continueBtn.setScale(1.1);
                });
                
                continueBtn.on('pointerout', () => {
                    continueBtn.setScale(1);
                });
                
                continueBtn.on('pointerdown', () => {
                    this.scene.start('GameScene', { 
                        level: this.currentLevel + 1,
                        score: this.score,
                        health: Math.min(5, this.health + 1) // Restore 1 health
                    });
                });
                
                // Celebration particles
                this.createCelebration();
            }

            createCelebration() {
                for (let i = 0; i < 50; i++) {
                    this.time.delayedCall(i * 50, () => {
                        const x = Phaser.Math.Between(100, 1100);
                        const particle = this.add.star(x, -20, 5, 5, 10, 0xFFD700);
                        
                        this.tweens.add({
                            targets: particle,
                            y: 620,
                            x: x + Phaser.Math.Between(-100, 100),
                            angle: 360,
                            alpha: { from: 1, to: 0 },
                            duration: Phaser.Math.Between(2000, 4000),
                            onComplete: () => particle.destroy()
                        });
                    });
                }
            }
        }

        // Victory Scene
        class VictoryScene extends Phaser.Scene {
            constructor() {
                super({ key: 'VictoryScene' });
            }

            init(data) {
                this.finalScore = data.score;
            }

            create() {
                // Victory background
                const graphics = this.add.graphics();
                const gradient = graphics.createLinearGradient(0, 0, 1200, 600);
                gradient.addColorStop(0, 0xFFD700);
                gradient.addColorStop(0.5, 0xFFA500);
                gradient.addColorStop(1, 0xFF8C00);
                graphics.fillGradientStyle(gradient);
                graphics.fillRect(0, 0, 1200, 600);
                
                // Victory title
                const title = this.add.text(600, 150, 'VICTORY!', {
                    fontFamily: 'Cinzel',
                    fontSize: '96px',
                    color: '#FFFFFF',
                    stroke: '#8B4513',
                    strokeThickness: 8
                });
                title.setOrigin(0.5);
                title.setShadow(5, 5, 'rgba(0,0,0,0.5)', 10);
                
                // Story conclusion
                const story = this.add.text(600, 280, 
                    'You have defeated Malathor and saved Princess Arithmia!\n' +
                    'The Crystal Kingdom is safe once more!',
                    {
                        fontFamily: 'MedievalSharp',
                        fontSize: '28px',
                        color: '#FFFFFF',
                        align: 'center',
                        lineSpacing: 10
                    }
                );
                story.setOrigin(0.5);
                
                // Final score
                const score = this.add.text(600, 380, `Final Score: ${this.finalScore}`, {
                    fontFamily: 'MedievalSharp',
                    fontSize: '36px',
                    color: '#FFD700',
                    stroke: '#8B4513',
                    strokeThickness: 3
                });
                score.setOrigin(0.5);
                
                // Play again button
                const playAgainBtn = this.add.rectangle(600, 480, 250, 70, 0x8B4513);
                playAgainBtn.setStrokeStyle(3, 0xD4AF37);
                playAgainBtn.setInteractive({ useHandCursor: true });
                
                const btnText = this.add.text(600, 480, 'Play Again', {
                    fontFamily: 'MedievalSharp',
                    fontSize: '32px',
                    color: '#FFD700'
                });
                btnText.setOrigin(0.5);
                
                playAgainBtn.on('pointerdown', () => {
                    location.reload();
                });
                
                // Fireworks
                this.createFireworks();
            }

            createFireworks() {
                this.time.addEvent({
                    delay: 500,
                    callback: () => {
                        const x = Phaser.Math.Between(200, 1000);
                        const y = Phaser.Math.Between(100, 300);
                        
                        for (let i = 0; i < 30; i++) {
                            const angle = (i / 30) * Math.PI * 2;
                            const particle = this.add.circle(x, y, 3, 
                                Phaser.Display.Color.RandomRGB(100, 255).color
                            );
                            
                            const distance = Phaser.Math.Between(50, 150);
                            this.tweens.add({
                                targets: particle,
                                x: x + Math.cos(angle) * distance,
                                y: y + Math.sin(angle) * distance,
                                alpha: 0,
                                duration: 1500,
                                ease: 'Cubic.out',
                                onComplete: () => particle.destroy()
                            });
                        }
                    },
                    repeat: -1
                });
            }
        }

        // Create the game
        const game = new Phaser.Game(config);
    </script>
</body>
</html>